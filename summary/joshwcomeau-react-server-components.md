## **A quick primer on Server Side Rendering**

rsc를 문맥으로 이해하려면, ssr이 어떻게 동작하는지 이해하는 것이 좋다. 만약 ssr에 익숙하다면, 다음으로 넘어가도 좋다.

대부분의 리액트 설정은 클라이언트 사이드였다. 유저는 다음과 같은 html 파일을 받을 것이다:

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
```

`bundle.js` 스크립트는 애플리케이션을 마운트하고 동작시키는 모든 것, 리액트와 써드 파티 라이브러리를 포함하고, 우리가 작성한 모든 코드를 포함한다.

자바스크립트가 다운되고 파싱되면, 리액트는 액션을 시작하고 모든 애플리케이션의 돔 노드에 마술을 부린 후 빈 `<div id="root">` 에 그것들을 채운다.

문제점은 이런 접근은 모든 것이 끝날 때까지 시간이 걸린다는 것이다. 그리고 이 동작이 진행될 때, 유저는 빈 화면을 보게된다. 이런 문제는 계속 심각해졌으며: 우리가 추가하는 기능들이 자바스크립트 번들에 킬로바이트를 추가했고, 유저가 앉아서 기다리는 시간을 연장했다.

서버 사이드 렌더링은 이런 경험을 개선하기 위해 설계 되었다. 빈 html을 보내는 것 대신, 서버는 실제 html을 생성해 애플리케이션을 렌더한다. 유저는 완전히 생성된 html 문서를 전달 받는다.

html 파일은 여전히 스크립트 태그를 포함하고, 우리는 여전히 클라이언트에서 동작해 상호작용을 다루는 리액트가 필요하다. 하지만, 우리는 브라우저에서 리액트의 동작을 살짝 다르게 설정할 수 있다: 모든 돔 노드를 다시 만드는 대신 기존 html을 선택하는 것. 이런 과정은 하이드레이션이라 알려져있다.

댄 아브라모브는 이것을 다음과 같이 설명한다

> 하이드레이션은 드라이한 html에 상호작용과 이벤트 핸들러라는 물을 주는 것과 같다.

자바스크립트 번들이 다운 되면, 리액트는 빠르게 우리의 전체 앱을 실행하고, ui의 가상 스케치를 작성한 후, 실제 돔에 적용한 후, 이벤트 핸드러 부착과 어떤 이펙트든 실행한다.

간단히 이것이 ssr이다. 자바스크립트 번들이 다운로드되고 파싱되는 동안 사용자가 빈 페이지를 볼 필요 없도록 서버는 초기 html을 생성한다. 클라이언트 사이드 리액트는 서버 사이드 리액트가 중단된 부분을 선택해 돔을 채택하고 상호 작용을 뿌린다.

<aside>
💡 포괄적인 용어

서버 사이드 렌더링을 이야기할 때, 우리는 다음과 같은 플로우를 생각한다:

1. 유저가 1. *myWebsite.com*에 방문한다.
2. 노드 서버가 요청을 받고, 즉시 리액트 애플리케이션을 렌더하고, html을 생성한다.
3. 갓 생성된 html이 클라이언트로 보내진다.

이것은 서버 사이드 렌더링을 구현하는 하나의 방법이지, 유일한 방법은 아니다. 다른 옵션은 정적 html을 빌드 시 생성하는 것이다.

일반적으로, 리액트 애플리케이션은 컴파일이 필요하다. jsx를 자바스크립트로 변경하고, 우리의 모듈을 번들링한다. 동일한 프로세스 중에 서로 다른 라우트의 모든 html을 프리렌더했다면 어떻게 될까?

이것은 정적 사이트 생성 ssg라고 불린다. 이것은 서버 사이드 렌더링의 하위 변형이다.

서버 사이드 렌더링은 하나의 포괄적인 용어로 여러 다른 렌더링 전략을 갖는다. 그들은 하나의 공통점을 갖는데: `ReactDOMServer` api를 사용해, 초기 렌더는 노드와 같은 서버 런타임에서 일어난다. 컴파일이든 요구에 의해서든, 언제 일어났는지는 중요하지 않다. 어느쪽이든 그것은 서버 사이드 렌더링이다.

</aside>

## **Bouncing back and forth**

리액트에서 데이터 페칭을 이야기해보자. 일반적으로, 우리는 네트워크와 통신하는 두 개의 다른 앱을 갖는다.

→ 클라이언트 사이드 리액트

→ 서버 사이드 rest api

리액트 쿼리, swr, 또는 아폴로를 사용해 클라이언트는 백엔드로 네트워크 요청을 한다. 데이터 베이스에서 데이터를 잡아 네트워크를 통해 전달한다.

첫 번째 그래프는 클라이언트 사이드 렌더링 전략을 보여준다. 이것은 클라이언트가 html 파일을 받으면 시작된다. 이 파일은 어떤 컨텐츠도 갖지 않으며, 하나 혹은 여러개의 스크립트 태그를 갖는다.

자바스크립트가 다운되고 파싱되면, 리액트 앱이 부팅되고, 돔 노드를 생성하고 UI를 채운다. 처음에는, 우리는 어떠한 실제 데이터를 갖지 않고, 로딩 상태와 오직 껍데기만 렌더한다.

유저는 네트워크 요청이 리졸브될 때까지 로딩 상태를 볼 것이고 리액트가 리렌더해, 로딩 ui를 실제 컨텐츠로 대체한다.

이것을 다른 방식으로 구조화할 수 있는 것을 보자. 다음 그래프는 동일한 데이터 페치 패턴으로, 클라이언트 사이드 렌더링 대신 서버 사이드 렌더링을 사용한다.

이런 새로운 흐름에서, 우리는 첫 렌더를 서버에서 한다. 즉 유저는 텅빈 html을 받지 않는다.

이것은 향상이지만 - 쉘이 텅빈 페이지 보단 낫다 - 하지만 궁극적으로, 상황을 실제로 눈에 띌정도로 변경하지는 않는다. 유저는 로딩 스크린을 보려고 우리의 앱을 방문하는 것이 아니고 그들은 컨텐츠를 보기 위해 방문한다.

다른 유저 경험의 실제로 이해하기 위해, 그래프에 웹 퍼포먼스를 추가하자.

1. **First Paint** — 유저가 더이상 빈 스크린을 보지않는 것. 일반적인 레이아웃이 렌더되지만, 컨텐츠는 여전히 없다. 이것은 때로 FCP (First Contentful Paint)로 불린다.
2. **Page Interactive** — 리액트가 다운로드 되고, 우리의 앱이 렌더/하이드레이트 되는 것. 상호작용하는 요소들이 완전히 반응한다. 이것은 TTI (Time To Interactive)로 불린다.
3. **Content Paint** — 유저가 관심 있어하는 컨텐츠가 포함되는 것. 데이터를 데이터베이스에서 가져와 ui로 렌더한다. 이것은 LCP (Largest Contentful Paint)라 불린다.

초기 렌더를 서버에서 하면, 우리는 초기 쉘을 더 빨리 얻을 수 있다. 이렇게 상황이 진행되고 있다는 느낌을 주기 때문에 로딩 경험이 좀 더 빠르게 느껴질 수 있습니다.

그리고 어떤 상황에서, 이것은 의미있는 향상이다. 예를 들어, 유저가 링크를 클릭해 이동하기 위해 오직 헤더의 로드만 기다리는 경우.

근데 이 플로우는 좀 이상하다. ssr 그래프를 봤을 때, 요청이 서버에서 시작된다는 것을 눈치채지 않을 수 없다. 두 번째 왕복 네트워크 요청 왕복 대신, 데이터베이스 작업을 첫 요청에 진행할 수 없을가?

즉, 왜 이렇게 안하는걸까?

클라이언트와 서버를 왔다 갔다하는 것 대신, 데이터베이스 쿼리를 초기 요청에 한다면, 완벽히 채워진 ui를 즉시 유저에게 보낼 수 있다.

근데, 어떻게 이걸 할 수 있을까?

이런 동작이 작동하려면, 우리는 데이터베이스 쿼리를 하는 리액트의 코드 청크를 서버에서만 실행시켜야한다. 근데, 이런 옵션은 리액트에 없다. 심지어 서버 사이드 렌더링을 하더라도 모든 컴포넌트는 서버와 클라이언트에서 렌더된다.

이런 문제를 풀기 위해 새로운 생태계가 등장했다. 넥스트나 개츠비 같은 프레임워크는 서버에서만 실행되는 그들의 고유한 코드를 생성했다.

예를 들어, 넥스트가 이것을 처리하는 방법이다. (레가시 페이지 라우터를 사용)

```tsx
import db from "imaginary-db";
// This code only runs on the server:
export async function getServerSideProps() {
  const link = db.connect("localhost", "root", "passw0rd");
  const data = await db.query(link, "SELECT * FROM products");
  return {
    props: { data },
  };
}
// This code runs on the server + on the client
export default function Homepage({ data }) {
  return (
    <>
      <h1>Trending Products</h1>
      {data.map((item) => (
        <article key={item.id}>
          <h2>{item.title}</h2>
          <p>{item.description}</p>
        </article>
      ))}
    </>
  );
}
```

이것을 분석해보자: 서버가 요청을 받을 시, `getServerSideProps` 함수가 호출된다. 이것은 `props` 객체를 반환한다. 이런 프랍은 서버에서 먼저 렌더되고 클라이언트에서 하이드레이트 되는 컴포넌트로 유입된다.

여기서 영리한 점은 `getServerSideProps` 가 클라이언트에서 재 실행되지 않는다는 것이다. 사실, 이 함수는 자바스크립트 번들에 포함되지도 않는다.

이 방식은 시대를 앞서갔다. 솔직히 정말 대단하다. 하지만 단점이 존재한다.

1. 이 방식은 오직 라우트 레벨인 트리의 최상위 컴포넌트에서만 동작한다. 모든 컴포넌트에서 할 수 없다.
2. 각 프레임워크 별로 각자의 방식이 존재한다. 넥스트는 넥스트의, 개츠비도, 리믹스도 각작의 방식을 갖는다. 이것은 표준화되지 않았다.
3. 모든 리액트 컴포넌트는, 불필요해도 클라이언트에서 항상 하이드레이트 된다.

해에 걸쳐, 리액트 팀은 조용히 이 문제를 생각하고 공식적인 해결책을 제시했다. 그들의 해결책은 리액트 서버 컴포넌트이다.

## **Introduction to React Server Components**

높은 수준에서, 리액트 서버 컴포넌트는 새로운 패러다임의 이름이다. 새로운 세계에서, 우리는 서버에서만 실행되는 컴포넌트를 생성할 수 있다. 이것은 데이터베이스 쿼리를 컴포넌트 내부에서할 수 있게 해준다.

```tsx
import db from "imaginary-db";
async function Homepage() {
  const link = db.connect("localhost", "root", "passw0rd");
  const data = await db.query(link, "SELECT * FROM products");
  return (
    <>
      <h1>Trending Products</h1>
      {data.map((item) => (
        <article key={item.id}>
          <h2>{item.title}</h2>
          <p>{item.description}</p>
        </article>
      ))}
    </>
  );
}
export default Homepage;
```

이것을 이해하기 위한 키: 서버 컴포넌트는 절대 리렌더하지 않는다. 그들은 오직 한번 서버에서 ui를 생성한다. 렌더의 값이 클라이언트로 보내지고 장소에 들어간다. 리액트의 관점에서, 이 결과물은 불변하고, 절대 변경되지 않는다.

즉, 이것은 리액트 api의 상당 부분이 서버 컴포넌트에 맞지 않는다는 것이다. 예를 들어, 서버 컴포넌트는 리렌더 될 수 없어 우리는 상태를 사용할 수 없는데, 상태는 변하기 때문이다. 또한, 우리는 이펙트를 사용할 수 없는데 이펙트는 렌더 이후에 일어나기 때문이다. 서버 컴포넌트는 절대 클라이언트에 도달하지 않는다.

이것은 또한 규칙과 사용했을 때 좀 더 유연하다. 예를 들어, 전통적인 리액트에서, 사이드 이펙트를 `useEffect` 콜백이나 이벤트 핸드러 또는 다른 무언가에 둬야지, 그들이 매 렌더마다 실행되지 않았다. 하지만, 컴포넌트가 오직 한번 실행되면, 이런 걱정을 하지 않아도 된다.

서버 컴포넌트 그들 자체는 놀랍도록 간단하지만, 리액트 서버 컴포넌트 패러다임은 훨씬 복잡하다. 그것은 우리가 여전히 일반적인 컴포넌트를 가지고 있으며, 그들을 결합하는 방식이 꽤 혼란스럽기 때문이다.

이 패러다임에서 우리가 익숙한 전통적인 리액트 컴포넌트는 클라이언트 컴포넌트라 불린다.

클라이언트 컴포넌트는 이 컴포넌트가 오직 클라이언트에서만 렌더되는 것을 의미하는데, 실제로는 거짓이다. 클라이언트 컴포넌트는 클라이언트와 서버에서 렌더 된다.

명칭이 제법 혼란스러우니, 정리를 해보자

→ 리액트 서버 컴포넌트는 새로운 패러다임의 이름이다.

→ 새로운 패러다임에서, 우리가 알고 사랑하는 스탠다드 리액트 컴포넌트는 클라이언트 컴포넌트로 리뉴얼된다. 오래된 것의 새로운 이름이다.

→ 새로운 패러다임은 새로운 타입의 컴포넌트인 서버 컴포넌트를 소개한다. 이 새로운 컴포넌트는 서버에서만 렌더한다. 그들의 코드는 자바스크립트 번들에 포함되지 않아서, 하이드레이트와 리렌더를 일으키지 않는다.

<aside>
💡 리액트 서버 컴포넌트 vs 서버 사이드 렌더링

또 다른 혼란을 해결해보자: 리액트 서버 컴포넌트는 서버 사이드 렌더링의 대체가 아니다. 리액트 서버 컴포넌트를 ssr 버전 2.0이라 생각해라.

대신에, 나는 그것을 완벽하게 결합되는 두 개의 퍼즐 조각, 서로 보완하는 두 가지 맛으로 생각하고 싶다.(스시와 와사비)

우리는 여전히 초기 html을 생성하기 위해 서버 사이드 렌더에 의존해야한다. 리액트 서버 컴포넌트는 그 상위에서 빌드되고, 몇 컴포넌트가 클라이언트 사이드 번들에서 생략되게 해주며, 오직 서버에서 실행되는 것을 보장한다.

사실, 리액트 서버 컴포넌트를 서버 사이드 렌더링 없이 사용하는 것은 가능하지만, 함께 사용하면 더 좋은 결과를 얻는다.

</aside>

## **Compatible Environments**

일반적으로, 리액트의 새로운 기능이 등장하면, 기존 프로젝트에 사용하기 위해 `npm install react@latest` 를 통해 우리는 경주에 다시 참여할 수 있다.

하지만, 리액트 서버 컴포넌트는 이런식으로 동작하지 않느다.

리액트 서버 컴포넌트는 리액트 외부의 번들러, 서버, 라우터의 통합이 필요하다.

현 시점에서 리액트 서버 컴포넌트를 사용하는 법은 넥스트 13.4+ 버전인 앱 라우터를 사용하는 것이다.

리액트의 핵심 기능이 특정한 툴에서만 가능하다는 것은 이상하다.

### **Specifying client components**

새로운 리액트 서버 컴포넌트 패러다임에서, 모든 컴포넌트는 기본적으로 서버 컴포넌트로 간주된다. 우리는 클라이언트 컴포넌트를 선택해야한다.

우리는 새로운 지시어를 특정할 수 있다:

```tsx
"use client";
import React from "react";
function Counter() {
  const [count, setCount] = React.useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>Current value: {count}</button>
  );
}
export default Counter;
```

이 최상단의 독립형 문자, `'use client'` 는 우리가 리액트의 컴포넌트를 클라이언트 컴포넌트로 실행하고, 자바스크립트 번들에 포함하고 클라이언트에서 리렌더될 수 있다는 것을 알려준다.

우리는 `'use server'` 지시어를 서버 컴포넌트에 지정할 필요없다. 리액트 서버 컴포넌트 패러다임에서 컴포넌트는 기본적으로 서버 컴포넌트로 간주된다. 사실, `'use server'` 는 서버 액션에 사용되므로 주제와는 벗어난다.

> \*\*Which components should be Client Components?

어떤 컴포넌트를 클라이언트로 하고 서버로 할지 고민할 것이다.

일반적인 룰에서, 서버 컴포넌트가 될 수 있다면, 서버 컴포넌트여야한다. 서버 컴포넌트는 추론하기 더 간단하고 쉽다. 또한, 성능 이점도 있다: 서버 컴포넌트가 서버에서 실행되지 않으므로, 그들의 코드는 자바스크립트 번들에 포함되지 않는다.
리액트 서버 컴포넌트 패러다임은 잠재적인 tti 향상 이점을 갖는다.

이것은 가능한 많은 리액트 컴포넌트를 줄이라는 것이 아니다. 클라이언트 컴포넌트를 작게 최적화 하면 안된다. 현재까지는, 모든 리액트 앱의 컴포넌트는 클라이언트 컴포넌트다.

리액트 서버 컴포넌트와 작업을 할 시, 이것이 매우 직관적이라는 것을 알 수 있다. 어떤 컴포넌트는 상태와 이펙트를 사용해, 클라이언트에서 동작을 해야한다.\*\* 이런 컴포넌트에 `'use client'` 지시어를 추가할 수 있다. 아니면, 그들을 서버 컴포넌트로 둬라.

>

## **Boundaries**

리액트 서버 컴포넌트를 사용하며 든 의문점은 프랍이 변경되면 어떻게 되는가이다.

예를 들어, 다음과 같은 서버 컴포넌트가 있다고 생각하자:

```tsx
function HitCounter({ hits }) {
  return <div>Number of hits: {hits}</div>;
}
```

첫 서버 사이드 렌더에서, `htis` 는 0과 같다. 그 후 이 컴포넌트는 마크업을 생성한다.

만약, `hits` 가 변경된다면? 이것이 상태 변수라고 생각하고 0에서 1로 변경된다고 가정하자. `HitCounter` 는 리렌더가 필요하지만, 서버 컴포넌트여서 리렌더할 수 없다.

문제는, 서버 컴포넌트는 단독으로 분리하면 실제로 의미가 없다. 줌아웃 해서, 좀 더 전체적인 시각으로, 애플리케이션의 구조를 살펴보자.

만약 모든 컴포넌트가 서버 컴포넌트라면, 모든것이 이해된다. 컴포넌트가 리렌더하지 않기에, 프랍은 변경되지 않을 것이다.

하지만, Article 컴포넌트가 hits 상태 변수를 갖는다고 가정하자. 상태를 사용하기 위해, 우리는 클라이언트 컴포넌트로 변경해야한다.

문제점을 발견했니? 아티클이 리렌더 될때, 자식 컴포넌트(힛카운터, 디스커션) 역시 리렌더 된다. 이것들이 서버 컴포넌트라면, 그들은 리렌더될 수 없다.

이런 불가능한 상황을 막기위해, 리액트 팀은 규칙을 추가했다: 클라이언트 컴포넌트는 오직 클라이언트 컴포넌트에서 import 되어야한다. `'use client'` 지시어는 그 하위의 인스턴스도 클라이언트 컴포넌트로 되어야한다는 것을 뜻한다.

리액트 서버 컴포넌트를 사용하며 가장 큰 아하 모먼트는 이 새로운 패러다임이 클라이언트 바운더리를 생성한다는 것이다.

'use client’ 지시어를 아티클 컴포넌트에 추가했을 때, 클라이언트 바운더리를 생성한다. 이 바운더리 내부의 컴포넌트는 암시적으로 클라이언트 컴포넌트로 변경된다. 힛카운터에 'use client’ 지시어가 없어도, 그들은 여전히 특정 상황에 클라이언트에서 하이드레이트/렌더 된다.

이것은 우리가 클라이언트에서 실행이 필요한 각 파일에 'use client’를 추가하지 않아도 된다는 것을 의미한다. 클라이언트 바운더리를 생성할 때만 추가하면 된다.

### **Workarounds**

클라이언트 컴포넌트가 서버 컴포넌트를 렌더하지 못하는 것은 제법 제한적입니다. 만약 애플리케이션 최상단에서 상태를 사용할 경우는? 이것이 모든 컴포넌트가 클라이언트로 되어야한다는 것을 의미할까?

```tsx
"use client";
import { DARK_COLORS, LIGHT_COLORS } from "@/constants.js";
import Header from "./Header";
import MainContent from "./MainContent";
function Homepage() {
  const [colorTheme, setColorTheme] = React.useState("light");
  const colorVariables = colorTheme === "light" ? LIGHT_COLORS : DARK_COLORS;
  return (
    <body style={colorVariables}>
      <Header />
      <MainContent />
    </body>
  );
}
```

이 설정에서, 유저가 리액트의 다크/라이트 모드를 변경할 수 있게 해야한다. 이것은 애플리케이션의 높은 트리에서 동작하고, css 토큰을 바디 태그에 적용할 수 있다.

상태를 사용하기 우해, 우리는 홈페이지 컴포넌트를 클라이언트 컴포넌트로 변경해야한다. 앱의 최상단에서, 이것은 헤더와 메인컨텐츠를 암시적으로 클라이언트 컴포넌트로 만든다는 것을 뜻한다.

이것을 해결하기 위해 색상 관리를 고유의 컴포넌트로 만들고 옮겨야한다.

```tsx
// /components/ColorProvider.js
"use client";
import { DARK_COLORS, LIGHT_COLORS } from "@/constants.js";
function ColorProvider({ children }) {
  const [colorTheme, setColorTheme] = React.useState("light");
  const colorVariables = colorTheme === "light" ? LIGHT_COLORS : DARK_COLORS;
  return <body style={colorVariables}>{children}</body>;
}
```

홈페이지에서, 우리는 컴포넌트를 다음과 같이 사용할 수 있다.

```tsx
// /components/Homepage.js
import Header from "./Header";
import MainContent from "./MainContent";
import ColorProvider from "./ColorProvider";
function Homepage() {
  return (
    <ColorProvider>
      <Header />
      <MainContent />
    </ColorProvider>
  );
}
```

홈페이지가 더이상 `'use client'` 지시어를 사용하지 않기에, 제거할 수 있다. 이것은 헤더와 메인컨텐츠가 더이상 암시적으로 클라이언튼 컴포넌트로 변경되지 않는 것을 뜻한다.

잠깐. 컬러프로바이더는 클라이언트 컴포넌트고, 헤더와 메인컨텐츠의 부모다. 같은 방식으로, 여전히 트리의 최상단이다.

클라이언트 바운더리에서, 부모/자식 관계는 중요하지 않다. 홈페이지는 헤더와 메인컨텐츠를 import 하고 렌더한다. 이것은 홈페이지가 이 컴포넌트의 프랍을 결정하는 것이다.

우리가 해결하려는 리액트 서버 컴포넌트의 문제는 리렌더 하지 않고, 프랍에서 어떤 새로운 값도 주지 못한다는 것이다. 이런 새로운 설정으로, 홈페이지는 헤더와 메인컨텐츠의 프랍을 결정하고, 홈페이지는 서버 컴포넌트이므로 이것은 문제가 되지 않는다.

이것은 머리를 써야하는 일이다.

좀 더 정확하게 `'use client'` 지시어는 파일/모듈 레벨에서 동작한다. 클라이언트 컴포넌트에 import된 어떤 모듈이든 클라이언트 컴포넌트가 된다. 번들러가 코드를 번들할 때, 이런 import를 따라간다.

## **Peeking under the hood**

이를 좀 더 낮은 수준에서 살펴보자. 우리가 서버 컴포넌트를 사용할 때, 아웃풋이 어떨까? 무엇이 실제로 생성될까?

```tsx
function Homepage() {
  return <p>Hello world!</p>;
}
```

리액트 서버 컴포넌트 패러다임에서, 모든 컴포넌트는 기본적으로 서버 컴포넌트이다. 우리가 명시적으로 클라이언트 컴포넌트로 명시하지 않는 이상, 이것은 서버에서만 렌더된다.

앱을 브라우저에서 접속 했을 때, html 문서를 다음과 같이 받을 것이다.

```tsx
<!DOCTYPE html>
<html>
  <body>
    <p>Hello world!</p>
    <script src="/static/js/bundle.js"></script>
    <script>
      self.__next['$Homepage-1'] = {
        type: 'p',
        props: null,
        children: "Hello world!",
      };
    </script>
  </body>
</html>
```

<aside>
💡 쉽게 이해하기 위해, 상황을 재구성하는 자유를 얻었다. 예를 들어, 실제로 자바스크립트가 생성한 rsc 컨텍스트는 문자화된 제이슨 배열을 사용해, html의 사이즈를 줄이는 최적화를 한다.

</aside>

우리는 리액트로 생성된 ui가 포함된 html 문서를 볼 수 있다. 이것은 서버 사이드 렌더링 덕분이며 리액트 서버 컴포넌트가 직접 기여하지 않았다.

그아래 우리는 자바스크립트 번들을 로드하는 스크립트 태그가 있다. 이 번들은 리액트 같은 의존성과, 클라이언트 컴포넌트를 포함한다. 우리의 홈페이지 컴포넌트가 서버 컴포넌트이기에, 번들에 포함되지 않는다.

최종적으로, 두 번째 스크립트 태그가 있다.

```tsx
self.__next["$Homepage-1"] = {
  type: "p",
  props: null,
  children: "Hello world!",
};
```

이것은 정말 흥미롭다. 본질적으로, 우리는 리액트에게 “야 너 홈페이지 컴포넌트 코드를 빠트린걸 알아, 근데 걱정하지마, 여기 코드가 있어”라고 말하는 것이다.

일반적으로, 리액트는 클라이언트에서 하이드레이트 되고, 모든 컴포넌트의 렌더를 하고, 앱의 가상 표현을 생성한다. 이것은 서버 컴포넌트에 사용할 수 없다. 코드가 자바스크립트 번들에 포함되지 않아서.

그래서 우리는 렌더링된 값, 즉 서버에서 생성된 가상의 표현을 함께 보낸다. 리액트가 클라이언트에서 로드되면 설명을 다시 생성하는 대신 해당 설명을 다시 사용한다.

컬러프로바이더 예가 동작하도록 해주는 예이다. 헤더와 메인컨텐츠는 컬러프로바이더의 자식 프랍으로 전달된다. 컬러프로바이더는 원하는 만큼 리렌더할 수 있지만, 데이터는 정적이고 서버에 갇혀있다.

## **Advantages**

리액트 서버 컴포넌트는 리액트에서 공식적으로 서버에서만 코드를 실행 첫 방법이다.

가장 큰 차이점은 우리가 우리의 컴포넌트 내부에서 서버에서만 실행되는 코드를 작성할 수 없었다는 것이다.

가장 명백한 이점은 성능이다. 서버 컴포넌트는 자바스크립트 번들에 포함되지 않는데, 다운되어야하는 자바스크립트 양과 하이드레이트 되어야 하는 컴포넌트 양을 줄인다.
