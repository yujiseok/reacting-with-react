- https://www.freecodecamp.org/news/how-to-use-react-server-components/

2020년에 리액트 팀이 “**Zero-Bundle-Size React Server Components”라는 개념을 소개했다. 그 후로, 리액트 개발자 커뮤니티는 서버 컴포넌트를 어떻게 적용할지 연구와 공부를 지속했다.**

리액트는 유저 인터페이스를 만드는 것에 대한 우리의 생각을 바꾸었다. 그리고 새로운 모델인 리액트 서버 컴포넌트를 사용하면 더 구조화 되고, 편리하며, 지속 가능한 유저 경험을 제공할 수 있다.

넥스트의 최신 버전은 “서버 컴포넌트로 생각하는 법”을 체택했다. 이런 새로운 멘탈 모델에 적응하고 애플리케이션을 만들 때 레버리징해야한다.

## 클라이언트 사이드 UI 라이브러리로써의 리액트

리액트는 클라이언트 사이드 유저 인터페이스 라이브러리이다. 이것은 자바스크립트 기반의 오픈 소스 라이브러리로 개발자가 웹 또는 모바일 애플리케이션을 컴포넌트 기반으로 만들 수 있게 해준다.

리액트는 작은 조각인 컴포넌트로 나눠 설계하는 방식을 제안한다.

![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F8587a611-937a-4b21-a548-105bd7bd2b91%2F52e18d56-da96-4361-be3a-0776f78dc1e4%2FUntitled.png?table=block&id=6f184d8a-57dd-4537-be8d-2d436bfcd16b&spaceId=8587a611-937a-4b21-a548-105bd7bd2b91&width=1720&userId=374375a4-b798-41ff-a41a-9394eb0d9780&cache=v2)

그러면 각 컴포넌트는 그들만의 프라이빗한 데이터인 `state` 와 데이터를 다른 컴포넌트로 전달하기 위한 `prop` 을 갖는다. 이런 컴포넌트를 컴포넌트 계층으로 분해하고, 상태를 정의하고, 상태 변경의 결과를 관리하고 데이터 흐름을 결정할 수 있다.

![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F8587a611-937a-4b21-a548-105bd7bd2b91%2F37146627-5578-41f2-bb3d-a46173782f45%2FUntitled.png?table=block&id=72eb0a2d-5b7e-4f63-8154-afe5f1524063&spaceId=8587a611-937a-4b21-a548-105bd7bd2b91&width=1530&userId=374375a4-b798-41ff-a41a-9394eb0d9780&cache=v2)

전통적으로, 모든 컴포넌트는 자바스크립트 함수이다. 앱이 브라우저에서 로드 되면, 컴포넌트 코드를 다운로드하고 그들을 사용해 앱이 동작하도록한다.

여기서 컴포넌트라는 개념을 설명했다. 하지만, 서버 컴포넌트를 설명하는 글이기에, 이런 전통적인 컴포넌트를 클라이언트 컴포넌트라고 부르자.

## 리액트 애플리케이션의 일반적인 문제점들

리액트 클라이언트 컴포넌트는 휼륭하며 특정 사례를 해결하는 데 효과적이다. 하지만, 리액트 애플리케이션을 만드는데 살짝 다른 패턴을 살펴봐야한다. 이것이 우리가 고려해야할 부분이다:

- 유저 경험: 우리는 유저와 고객을 위한 소프트웨어 제품을 만든다. 앱이 성공적이려면 유저 경험이 중요하다.
- 유지보수성: 프로젝트 코드는 반드시 여러 해와 개발 팀으로 부터 잘 유지되어야한다.
- 성능 비용: 애플리케이션이 느려져서는 안되며 디자인 접근 방식이 속도를 늦추어서도 안된다.

마주할 수 있는 일반적인 문제를 살펴보자.

### \***\*The Layout Shift Problem\*\***

매우 일반적인 유저 경험 문제는 컴포넌트가 렌더 시 일어나는 갑작스러운 레이아웃 쉬프트이다.

```jsx
<CourseWraper>
  <CourseList />
  <Testimonials />
</CourseWraper>
```

jsx 코드는 CourseWraper 컴포넌트와 CourseList, Testimonials 두 자식 컴포넌트를 갖는다. 두 자식 컴포넌트가 네트워크 요청을 통해 데이터를 페치한다고 가정하자.

```jsx
function CourseList() {
  // Assume a Network Call, in real-life
  // you will handle it with useEffect
  const info = fetchCourseList();

  return <> </>;
}

function Testimonials() {
  // Assume a Network Call, in real-life
  // you will handle it with useEffect
  const info = fetchTestimonials();

  return <> </>;
}
```

이러한 컴포넌트가 네트워크 요청을 하면, 어떤 응답이 먼저 올지 보장할 수 없다. 이것은 네트워크 속도, 지연 시간 그리고 다른 많은 요소에 달려있다.

Testimonials 컴포넌트의 요청이 CourseList의 요청보다 먼저 완료될 경우, CourseList 컴포넌트가 렌더된 후 CourseList 컴포넌트가 렌더 된다. 이것은 CourseList 컴포넌트를 맞는 위치로 밀어낼 것이다.

![](https://www.notion.so/image/https%3A%2F%2Fwww.freecodecamp.org%2Fnews%2Fcontent%2Fimages%2F2023%2F07%2Flayoutshift-1.gif?table=block&id=7f1f428a-9248-4032-bced-0470afd8a8b5&spaceId=8587a611-937a-4b21-a548-105bd7bd2b91&userId=374375a4-b798-41ff-a41a-9394eb0d9780&cache=v2)

로딩 인디케이터 또는 반짝임 효과로 유저에게 잠시 후의 무언가를 기대할 수 있도록 경험을 좀 더 좋게 할 수 있다.

### 네트워크 워터폴 문제

또 하나의 전형적인 유저 경험 문제를 이야기해보자. 다음과 같은 리액트 컴포넌트가 있다고 생각하자.

```jsx
function Course() {
  return (
    <CourseWraper>
      <CourseList />
      <Testimonials />
    </CourseWraper>
  );
}
```

코드를 살짝 변경해 CourseWrapper 역시 네트워크 요청을 하도록 변경한다.

```jsx
function CourseWrapper() {
  // Assume a Network Call, in real-life
  // you will handle it with useEffect
  const info = fetchWrapperInfo();

  return <> </>;
}
```

이제, 부모 컴포넌트가 네트워크 요청을 하고, 자식 컴포넌트 역시 네트워크 요청을 한다.

흥미로운 점은 이것으로, 부모 컴포넌트는 네트워크 요청이 완료되기 전까지 렌더되지 않는다. 이것은 자식 컴포넌트의 렌더링 역시 지연시킨다.

이전 작업의 응답이 완료되어 현재 작업이 시작되기를 기다리는 이러한 현상을 워터폴이라고 한다. 이 경우 우리는 네트워크 워터폴과 컴포넌트 렌더링 워터폴을 동시에 갖는다.

모든 네트워크 요청을 끌어올려 개별 컴포넌트가 응답을 기다리지 않도록 단일 요청으로 만드는 것을 생각할 것이다. 이것은 현명하지만, 유지보수의 어려움이 있다.

### 유지보수 이슈

서버 측 상호 작용과 관련된 몇 가지 유저 경험 문제를 살펴보았고, 유지 보수 이슈를 고려해본다.

모든 컴포넌트가 네트워크 요청을 하지 않는다고 가정하자. 하나의 api fetchAllDetails()에서 모든 컴포넌트를 위한 데이터를 페치한다고 가정하자.

그리고 정보를 각 컴포넌트의 프랍으로 전달한다. 이것은 이전의 워터폴 문제보단 낫다 맞지?

```jsx
function Course() {
  // Assume a Network Call, in real-life
  // you will handle it with useEffect
  const info = fetchAllDetails();

  return (
    <CourseWrapper ino={info.wrapperInfo}>
      <CourseList ino={info.listInfo} />
      <Testimonials ino={info.testimonials} />
    </CourseWrapper>
  );
}
```

하지만, 이것은 유지보수 이슈를 일으킨다.

어느 날, 제품이 후기 기능을 삭제하기로 결정했다고 가정하자. 위 코드에서 후기 컴포넌트를 제거할 수 있다. 이것은 제대로 작동한다. 하지만, `fetchAllDetails()` 호출을 사용하여 얻은 데이터를 정리하는 것을 잊어버릴 수 있다. 사용하지 않고 불필요하게 존재할 수도 있다.

### 성능 비용

마지막 문제는 성능 비용이다.

![Untitled](https://images.ctfassets.net/em6l9zw4tzag/456jhw5o4NHnhE9I6DOiDC/b62c3a3018dc55944d1168665bf0e21d/bundle-size-matters-hero.jpg)

전통적으로, 리액트 컴포넌트는 클라이언트 사이드 자바스크립트 함수이다. 그들은 리액트 애플리케이션의 빌딩 블록이다. 우리가 애플리케이션을 클라이언트에서 로드할 시, 컴포넌트는 클라이언트에서 다운되고 리액트는 렌더링에 필요한 작업을 한다.

하지만 이것은 두 가지 문제를 유발한다:

첫 째로, 유저가 요청을 보내면, 앱은 html을 자바스크립트, css 그리고 에셋들과 함께 다운한다.

브라우저에서, 리액트는 html 구조 렌더와 하이드레이트를 시작한다. html을 파싱하고, 이벤트 리스너를 돔에 부착하고 데이터를 스토어에서 페치한다. 그 후, 사이트는 완전히 리액트 앱으로 구동된다.

그러나, 요점은 클라이언트에서 많은 일이 일어나고 있다는 것이다. 결국 우리는 이 코드를 모드 클라이언트에서 다운로드하게 된다.

대부분 우리는 프로젝트에 추가적인 라이브러리를 의존성으로 필요로한다. 모든 의존성은 클라이언트 측에서 다운로드 되며 부피를 크게한다.

이제 문제를 알았으니, 리액트 서버 컴포넌트가 어떻게 이런 문제를 해결했는지 감사할 것이다.

그 전에, 서버와 클라이언트의 이해가 필요하다.

## 클라이언트-서버 모델

- 클라언트: 애플리케이션과 관련된 클라이언트는 유저 측에서 작업을 실행하는 시스템이다. 클라이언트의 예는 pc, 노트북, 모바일, 브라우저 등이 있다.
- 서버: 서버는 이름에서도 알 수 있듯, 서비스를 클라이언트에 제공하는 것이다. 이것은 데이터 스토어 또는 데이터베이스를 위치시켜 빠르게 데이터에 접근한다.
- 요청: 요청은 클라이언트가 서버에 서비스를 요청하는 커뮤니케이션 모드이다.
- 응답: 응답은 서버가 클라이언트에게 서비스를 전달하는 커뮤니케이션이다.

## 리액트 클라이언트 컴포넌트

전통적인 리액트 컴포넌트는 클라이언트에 존재한다. 그들이 서버와 상호작용할 때, 그들은 요청을 보내고 응답이 오길 기다린다. 응답을 받고, 클라이언트는 다음 액션을 트리거한다.

만약 요청 서비스가 성공적으로 완료되면, 클라이언트 컴포넌트는 ui에서 작동하고 성공 메시지를 보여준다. 오류가 발생하는 경우 클라이언트 구성 요소는 이를 사용자에게 보고한다.

네트워크 워터폴을 일으키면, 클라이언트 컴포넌트의 응답은 지연되고 좋지 않은 유저 경험을 제공한다.

## 어떻게 리액트 서버 컴포넌트가 도움을 주는지

우리의 리액트 컴포넌트를 서버로 옮기면 어떨까?

이 새로운 컴포넌트는 데이터를 서버에서 더 빠르게 페치할 수 있다. 이들은 파일 시스템이나 데이터 스토어와 같은 서버 인프라에 네트워크 왕복 없이 접근할 수 잇다.

이제 우리는 서버 컴포넌트 측면에서 생각해야 하므로, 리액트 개발자에게는 완전한 패러다임 전환이다.

rsc를 통해, 데이터 페치 로직을 서버로 옮길 수 있으며 서버 자체에서 준비할 수 있다. 클라이언트로 돌아오는 데이터는 그에 맞는 모든 데이터와 함께 구성된 컴포넌트이다.

서버 컴포넌트를 사용하면 다음과 같이 코드를 작성할 수 있다.

```jsx
import { dbConnect } from "@/services/mongo";

import { addCourseToDB } from "./actions/add-course";

import CourseList from "./components/CourseList";

export default async function Home() {
  // Get a MongoDB connection
  await dbConnect();

  // Get all courses from the db using model
  const allCourses = await courses.find();

  // This gets printed on the server console
  console.log({ allCourses });

  return (
    <main>
      <div>
        <CourseList allCourses={allCourses} />
      </div>
    </main>
  );
}
```

- 컴포넌트 자체로 async를 사용해 비동기 호출을 다룬다.
- 컴포넌트 자체에서 데이터베이스와 연결한다.
- 데이터베이스를 쿼리하고 데이터를 넘겨 jsx를 렌더한다.

콘솔 로그는 정보들을 브라우저가 아닌 서버 콘솔에서 보여질 것이다.

또한, 상태 관리와 이펙트를 지울 수 있다.

리액트 서버 컴포넌트를 사용하면, `useEffect` 가 필요없다.

### 서버 컴포넌트의 한계

이런 장점에도, 리액트 서버 컴포넌트는 한계를 갖는다:

- 리액트 서버 컴포넌트는 서버에 존재하고 서버에서 렌더된다. 그들은 클라이언트 사이드와 관련된 어떤 기능도 갖지 않는다. 즉 서버 컴포넌트에 유저 상호작용을 추가할 수 없다. 예를 들어, 어떠한 이벤트 핸들러 또는 리액트 훅을 서버에서 사용할 수 없다.
- 로컬스토리지, 블루투스, 웹 usb와 같은 브라우저의 웹 api를 사용할 수 없다.
- 모든 것이 클라이언트 상호작용에 달려있다면, 클라이언트 컴포넌트를 사용해야 한다.

### 클라이언트와 서버 컴포넌트를 함께 사용하는 법

서버와 클라이언트 컴포넌트를 결합할 수 있다.

서버 컴포넌트는 클라이언트 컴포넌트를 불러오고 렌더할 수 있지만, 클라이언트 컴포넌트는 서버 컴포넌트를 렌더할 수 없다. 만약 서버 컴포넌트를 클라이언트 컴포넌트에서 사용하고 싶다면, 프랍으로 넘겨줘야한다.

서버 컴포넌트를 루트에 두고 클라이언트 컴포넌트를 계층의 최하위로 두는 것이 좋다.

데이터 페칭은 서버 컴포넌트 상단에서 발생해 전달될 수 있다. 유저 상호작용 및 브라우저 api는 리프 수준의 클라이언트 컴포넌트에서 처리 될 수 있다.

### 리액트 서버 컴포넌트가 서버 사이드 렌더링이랑 다른것이라고?

다른다. 리액트 서버 컴포넌트와 서버 사이드 렌더링은 “서버”라는 단어를 갖지만, 그 뿐이다.

서버 사이드 렌더링에서, 로우한 html을 서버에서 클라이언트로 보낸 후, 모든 클라이언트 사이드 자바스크립트가 다운된다. 리액트는 상호작용 가능한 컴포넌트로 만들기 위해 하이드레이션 과정을 거친다. 서버 사이드 렌더링에서는 컴포넌트가 서버에 머무르지 않는다.

리액트 서버 컴포넌트는, 컴포넌트가 서버에 머무르며 네트워크 왕복 없이 서버 인프라에 접근한다.

서버 사이드 렌더링은 첫 페이지 로딩이 빨라 유용하다. 아무 문제 없이 두 가지를 같이 사용할 수 있다.
