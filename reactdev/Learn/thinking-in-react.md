- [Thinking in React](#thinking-in-react)
  - [Step 1: Break the UI into a component hierarchy](#step-1-break-the-ui-into-a-component-hierarchy)
  - [Step 2: Build a static version in React](#step-2-build-a-static-version-in-react)
  - [Step 3: Find the minimal but complete representation of UI state](#step-3-find-the-minimal-but-complete-representation-of-ui-state)
  - [Step 4: Identify where your state should live](#step-4-identify-where-your-state-should-live)
  - [Step 5: Add inverse data flow](#step-5-add-inverse-data-flow)
  - [What I Learned](#what-i-learned)

# Thinking in React

리액트는 우리가 만드는 앱과 디자인에 대한 생각을 바꿀 수 있습니다.
우리가 리액트로 인터페이스를 만든다면, 먼저 우리는 컴포넌트 단위로 인터페이스를 나눌 것입니다. 그 후 각각의 컴포넌트별로 다른 시각적 상태를 구독시킬 것입니다. 마지막으로 컴포넌트를 연결시키고 데이터가 흐르도록 할 것입니다.

## Step 1: Break the UI into a component hierarchy

박스를 그리며 컴포넌트를 나누는 것을 시작하고 그들에 이름을 지어줍니다. 만약 당신이 디자이너와 일한다면, 이미 그들이 컴포넌트의 이름을 지었을 것입니다!

당신의 배경에 따라 다른 방식으로 컴포넌트를 나눌 것입니다.

- Programming: 프로그래밍의 하나의 기술인 단일 책임 원칙을 이용해 컴포넌트를 만들 것입니다. 단일 책임 원칙에 따르면 컴포넌트는 오직 한 가지 일만 해야 합니다. 만약 컴포넌트가 비대해지면, 더 작은 컴포넌트 단위로 나뉘어야 합니다.

- CSS: 클래스 선택자를 만드는 것처럼 생각합니다. (물론 컴포넌트가 더 세분화되어 있습니다.)

- Design: 디자인 레이어를 어떻게 설계하였는지에 따라 고려할 것입니다.

만약 `JSON`이 잘 구성되어 있다면, 컴포넌트 구성과 자연스럽게 매핑되는 경우가 많습니다.
왜냐하면, UI와 데이터 모델은 같은 정보 아키텍처를 가질 때가 많기 때문입니다. 각 컴포넌트가 한 조각의 데이터 모델과 일치하는 부분에서 UI를 컴포넌트로 나눕니다.

스크린에 다섯 개의 컴포넌트들이 있습니다.

![](https://react.dev/images/docs/s_thinking-in-react_ui_outline.png)

1. `FilterTableProduct`은 전체 앱을 감쌉니다.
2. `SearchBar`는 유저의 입력을 받습니다.
3. `ProductTable`은 유저의 입력에 따른 목록을 필터링해 보여줍니다.
4. `ProductCategoryRow`는 각 카테고리의 제목을 보여줍니다.
5. `ProductRow`는 각각의 상품을 열로 보여줍니다.

`ProductTable` 안에서, 당신은 컴포넌트가 아닌 테이블 헤더를 볼 수 있습니다. 이것은 당신의 선택의 문제입니다. 이 예제에서는 `ProductTable` 부분 중 하나인데, 그 이유는 `ProductTable` 내부에서 보여지기 때문입니다. 하지만, 헤더가 커지고 복잡해지면(e.g 정렬), `ProductTableHeader` 컴포넌트로 만들 수 있을 것입니다.

이제 당신은 목업으로부터 컴포넌트들의 이름을 지었으며, 계층에 따라 정렬할 수 있습니다. 다른 컴포넌트 내부에 등장하는 컴포넌트들은 자식 계층에 나타납니다.

- `FilterableProductTable`
  - `SearchBar`
  - `ProductTable`
    - `ProductCategoryRow`
    - `ProductRow`

## Step 2: Build a static version in React

이제 컴포넌트의 계층을 가졌으니, 앱을 발전시킬 차례입니다. 가장 간단한 접근은 상호작용 없이 UI를 만드는 것입니다.
종종 정적인 버전을 만들고 나중에 상호작용을 추가하는 것은 더 쉽습니다. 정적인 버전을 만드는 것은 많은 타이핑을 요구하지만, 생각이 필요 없습니다. 하지만 상호작용을 추가하는 것은 많은 생각이 필요합니다.

당신의 데이터를 정적으로 렌더해줄 버전의 앱을 만들기 위해, 당신은 데이터를 props로 넘겨주는 재사용 가능한 컴포넌트들을 만들고 싶어할 것입니다. props는 데이터를 부모에서 자식으로 넘겨주는 방식입니다.

최상위 계층인 `FilterableProductTable`에서 만드는 "top down" 방식과 최하위 계층인 `ProductRow`에서 만드는 "bottom up" 방식 둘 다 가능합니다. 간단한 예제로, top-down 방식이 더 쉽습니다. 만약 큰 프로젝트라면 bottom-up 방식이 더 쉽습니다.

컴포넌트들을 다 만들면, 당신은 당신의 데이터 모델을 활용해 재사용할 수 있는 컴포넌트들을 갖게 될 것입니다. 이 예제는 정적인 앱이기에, 컴포넌트들이 JSX만을 리턴합니다. 최상위 계층에 있는 컴포넌트는 데이터 모델을 prop으로 받을 것입니다.
데이터가 최상위 컴포넌트에서 최하위 컴포넌트로 흐르기 때문에 이것을 **one-way-dataflow**(단방향 데이터)라고 합니다.

## Step 3: Find the minimal but complete representation of UI state

UI를 상호작용하게 하려면, 유저가 당신의 데이터 모델을 바꿀 수 있게 해야 합니다. 당신은 이것을 위해 상태를 사용할 것입니다.

상태를 당신의 앱의 기억해야 하는 데이터를 변경하는 최소한의 세트라고 생각하세요. 가장 중요한 원칙은 상태를 [DRY (Don’t Repeat Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 하게 설계하는 것입니다.
당신의 앱에서 필요하고 모든 것을 요구에 따라 계산할 수 있는 가장 최소한의 상태를 찾아내야 합니다.
예를 들어, 당신이 구매 목록을 만들고 싶으면, 아이템 배열을 상태로 저장할 수 있습니다. 하지만, 목록의 길이는 상태로 관리하지 말아야 합니다. 대신 배열의 길이로 읽어옵니다.

위 예제의 모든 데이터를 생각해봅시다.

1. 원본 상품 목록들
2. 유저가 입력하는 검색어
3. 체크박스의 값
4. 필터 된 목록들

어떤 것이 상태인지 구분해 봅시다.

- **시간이 지나도 바뀌지 않는다면** 그것은 상태가 아닙니다.
- **부모에게 props로 내려받았다면** 그것은 상태가 아닙니다.
- **props나 상태로 계산할 수 있는 값이라면** 그것은 명백히 상태가 아닙니다!

무엇이 상태일 가능성이 있을까요?

1. 원본 목록은 **props로 내려받으므로 이것은 상태가 아닙니다**.
2. 검색어는 매시간에 걸쳐 변화하며 어디서도 계산할 수 없기에 상태인 것 같습니다.
3. 체크박스의 값은 매시간에 걸쳐 변화하며 어디서도 계산할 수 없기에 상태인 것 같습니다.
4. 필터 된 리스트는 원복 목록에서 **계산될 수 있기 때문에** 상태가 아닙니다.

즉 검색어와 체크박스의 값만이 상태입니다.

## Step 4: Identify where your state should live

최소한의 상태를 찾았다면, 어떤 컴포넌트가 상태를 가질지 정해야 합니다. 기억하세요. 리액트는 단방향 데이터 흐름을 가지므로 부모에서 자식으로 데이터를 넘겨줍니다. 어떤 컴포넌트가 상태를 가질지는 당장 모호합니다. 처음이라면 이것은 제법 도전이 될지도 모릅니다. 하지만, 아래 단계를 거치면 당신은 어떤 컴포넌트가 상태를 가질지 알 수 있습니다.

1. 모든 컴포넌트가 상태로 렌더링 되는지 알아냅니다.
2. 그들의 가장 가까운 부모 컴포넌트를 찾아냅니다. - 최상위 계층
3. 어디에 상태가 존재할지 정합니다.
   1. 종종 부모 컴포넌트에 상태를 둘 수 있습니다.
   2. 또 부모 컴포넌트의 위에 있는 컴포넌트에 둘 수 있습니다.
   3. 만약 어디에 둘지 모르겠다면, 상태를 가지기만 하는 새로운 컴포넌트를 만들고 부모 컴포넌트 위 계층에 둡니다.

위의 예제에서 두 상태는, 항상 같이 나타나므로 같은 곳에 두는 것이 말이 됩니다.

이제 그들을 위한 전략을 살펴보겠습니다.

1. 상태를 사용하는 컴포넌트를 정한다.

- `ProductTable`은 상태에 따른 필터가 된 상품 목록이 필요합니다.
- `SearchBar`는 상태를 나타내야 합니다.

2. 그들의 부모 컴포넌트를 찾습니다. 둘의 첫 번째 부모 컴포넌트는 `FilterableProductTable`입니다.

3. 어디에 상태가 존재할지 정합니다. `FilterableProductTable`에 상태를 가지도록 합니다.

즉 상태는 `FilterableProductTable` 컴포넌트에 존재할 것입니다.

`useState` 훅을 통해 컴포넌트에 상태를 추가합니다. 훅은 리액트에 연결할 수 있도록 해주는 특별한 함수들입니다.
초기 상태와 함께 상태를 정의합니다.

그 후 `ProductTable`와 `SearchBar`에 props로 넘겨줍니다.

## Step 5: Add inverse data flow

이제 앱은 상태와 props를 통해 아래 계층으로 흐르며 렌더링 됩니다. 하지만, 유저의 입력에 따른 상태 변경은 다른 방식의 데이터 흐름이 필요합니다.

리액트는 이 데이터 흐름을 명시적으로 만드는데, two-way 데이터 바인딩 보단 많은 입력이 필요합니다. `input`의 `value` prop을 설정하면 위에서 넘겨받은 상태와 항상 같습니다. 상태가 바뀌지 않는 한 입력은 절대 변하지 않습니다.

유저의 입력에 따라 상태를 변경 시키고 싶을 것입니다. 상태는 `FilterableProductTable`에 존재하므로 여기에서만 set 해주는 함수를 호출할 수 있습니다. 상태를 갖는 컴포넌트를 변경하기 위해 이 함수를 아래로 넘겨줍니다.

이제 `onChange` 이벤트를 통해 상태를 변경시킬 수 있게 되었습니다!

---

## What I Learned

리액트에서 상태를 관리하는 것이 정말 어려운데, 어떤 기준으로 상태를 관리하고 어떤 컴포넌트에게 책임을 쥐여줄지 좀 더 생각할 수 있게 된 것 같다. 알면 알수록 리액트의 단 방향 데이터 흐름은 재밌으면서도 어려운 것 같다.

> 지금까지 리액트를 사용하면서 굳이 상태로 관리 안 해도 될 것들을 상태로 관리한 건 아닐까 하는 생각도 들었다.

출처

- https://react.dev/learn/thinking-in-react
